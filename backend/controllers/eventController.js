const Event = require("../models/Event");
const Participant = require("../models/Participant");
const ActivityLog = require("../models/ActivityLog");
const Certificate = require("../models/Certificate");
const { sendEventNotificationToAll } = require("../utils/emailService");
const certificateScheduler = require("../utils/certificateScheduler");
const certificateHelper = require("../utils/certificateHelper");

// @desc    Create event
// @route   POST /api/events
// @access  Private/Admin
exports.createEvent = async (req, res) => {
  try {
    const {
      name: rawName,
      description,
      date,
      participants: rawParticipantIds = [],
    } = req.body;

    const name = (rawName || "").trim();
    if (!name) {
      return res.status(400).json({
        success: false,
        message: "Event name is required",
      });
    }

    // Check for duplicate event name (case-insensitive)
    const existingEvent = await Event.findOne({
      name: { $regex: `^${name.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}$`, $options: "i" },
    });

    if (existingEvent) {
      return res.status(400).json({
        success: false,
        message: "Event with this name already exists",
      });
    }

    // Ensure participant IDs are unique and valid ObjectId strings
    const participantIds = Array.isArray(rawParticipantIds)
      ? [...new Set(rawParticipantIds.filter(Boolean))]
      : [];

    const event = await Event.create({
      name,
      description,
      date,
      createdBy: req.user._id,
    });

    // Attach participants to the event if provided
    if (participantIds.length > 0) {
      const participants = await Participant.find({
        _id: { $in: participantIds },
        email: { $exists: true, $ne: "" },
      }).select("_id");

      if (participants.length > 0) {
        const participantObjectIds = participants.map((p) => p._id);

        event.participants = participantObjectIds;
        await event.save();

        await Participant.updateMany(
          { _id: { $in: participantObjectIds } },
          { eventId: event._id }
        );
      }
    }

    // Automatically create certificate template for this event
    try {
      await Certificate.create({
        eventId: event._id,
        templateImage: "sistec-template", // Using built-in template
        templateType: "sistec", // Default template type
        namePlaceholder: {
          x: 421,
          y: 240,
          fontSize: 24,
          fontFamily: "Helvetica-Bold",
          color: "#000000",
        },
        createdBy: req.user._id,
      });
      console.log(`Certificate template auto-created for event: ${event.name}`);

      // Schedule certificate generation at 10:30 PM on event day
      const scheduleResult =
        certificateScheduler.scheduleEventCertificateGeneration(event);
      if (scheduleResult) {
        console.log(
          `Certificate generation scheduled for event: ${event.name} at 10:30 PM on ${event.date}`
        );
      } else {
        console.log(
          `Event ${event.name} date may have passed, certificates will be generated by daily scheduler if needed`
        );
      }
    } catch (error) {
      console.error("Error creating certificate template:", error);
      // Don't fail event creation if certificate template creation fails
    }

    // Send email notifications to participants about the upcoming event
    try {
      const notificationResult = await sendEventNotificationToAll(
        event,
        event.participants
      );
      console.log(`Event notification emails: ${notificationResult.message}`);
      if (notificationResult.errors && notificationResult.errors.length > 0) {
        console.error("Some emails failed to send:", notificationResult.errors);
      }
    } catch (error) {
      console.error("Error sending event notification emails:", error);
    }

    // Log activity
    await ActivityLog.create({
      userId: req.user._id,
      action: "Event created",
      details: { eventId: event._id, name },
      status: 201,
    });

    res.status(201).json({
      success: true,
      message:
        "Event created successfully. Notification emails are being sent to all participants.",
      data: event,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Get all events
// @route   GET /api/events
// @access  Private
exports.getEvents = async (req, res) => {
  try {
    const events = await Event.find()
      .populate("participants", "name email semester")
      .populate("createdBy", "name email")
      .sort({ date: -1 });

    const eventsWithCounts = await Promise.all(
      events.map(async (event) => {
        const participantCount = await Participant.countDocuments({
          eventId: event._id,
        });
        const eventObj = event.toObject();
        eventObj.participantCount = participantCount;
        eventObj.participants = eventObj.participants || [];
        return eventObj;
      })
    );

    res.status(200).json({
      success: true,
      count: eventsWithCounts.length,
      data: eventsWithCounts,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Get single event
// @route   GET /api/events/:id
// @access  Private
exports.getEvent = async (req, res) => {
  try {
    const event = await Event.findById(req.params.id)
      .populate("participants", "name email semester customFields")
      .populate("createdBy", "name email");

    if (!event) {
      return res.status(404).json({
        success: false,
        message: "Event not found",
      });
    }

    const participantCount = await Participant.countDocuments({
      eventId: event._id,
    });

    const eventObj = event.toObject();
    eventObj.participantCount = participantCount;

    res.status(200).json({
      success: true,
      data: eventObj,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Update event
// @route   PUT /api/events/:id
// @access  Private/Admin
exports.updateEvent = async (req, res) => {
  try {
    const event = await Event.findByIdAndUpdate(req.params.id, req.body, {
      new: true,
      runValidators: true,
    });

    if (!event) {
      return res.status(404).json({
        success: false,
        message: "Event not found",
      });
    }

    await ActivityLog.create({
      userId: req.user._id,
      action: "Event updated",
      details: { eventId: req.params.id, updates: req.body },
      status: 200,
    });

    res.status(200).json({
      success: true,
      message: "Event updated successfully",
      data: event,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Delete event
// @route   DELETE /api/events/:id
// @access  Private/Admin
exports.deleteEvent = async (req, res) => {
  try {
    const event = await Event.findById(req.params.id);
    if (!event) {
      return res.status(404).json({
        success: false,
        message: "Event not found",
      });
    }

    await Participant.updateMany(
      { eventId: req.params.id },
      { $unset: { eventId: 1 } }
    );

    await event.deleteOne();

    await ActivityLog.create({
      userId: req.user._id,
      action: "Event deleted",
      details: { eventId: req.params.id, name: event.name },
      status: 200,
    });

    res.status(200).json({
      success: true,
      message: "Event deleted successfully",
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};

// @desc    Add participants to event
// @route   POST /api/events/:id/participants
// @access  Private/Admin
exports.addParticipantsToEvent = async (req, res) => {
  try {
    const { participantIds } = req.body;

    const event = await Event.findById(req.params.id);
    if (!event) {
      return res.status(404).json({
        success: false,
        message: "Event not found",
      });
    }

    await Participant.updateMany(
      { _id: { $in: participantIds } },
      { eventId: req.params.id }
    );

    event.participants = [
      ...new Set([
        ...event.participants.map((p) => p.toString()),
        ...participantIds,
      ]),
    ];
    await event.save();

    // Generate certificates for new participants if event date is today or has passed
    certificateHelper
      .generateCertificatesForNewParticipants(req.params.id, participantIds)
      .then((result) => {
        if (result.success) {
          if (result.successful > 0) {
            console.log(
              `[Event Controller] Automatically generated ${result.successful} certificate(s) for new participants in event: ${event.name}`
            );
            console.log(
              `[Event Controller] Certificates will be sent automatically at 11:59 PM`
            );
          } else if (result.scheduled) {
            console.log(
              `[Event Controller] Certificates will be generated automatically at 10:30 PM and sent at 11:59 PM on event day for event: ${event.name}`
            );
          }
        }
      })
      .catch((error) => {
        console.error(
          `[Event Controller] Error generating certificates for new participants:`,
          error
        );
      });

    await ActivityLog.create({
      userId: req.user._id,
      action: "Participants added to event",
      details: { eventId: req.params.id, participantIds },
      status: 200,
    });

    res.status(200).json({
      success: true,
      message:
        "Participants added to event successfully. Certificates will be generated at 10:30 PM and sent at 11:59 PM automatically if event date has passed.",
      data: event,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message,
    });
  }
};
